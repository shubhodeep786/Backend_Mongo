// Generated by CodiumAI

describe("code snippet", () => {
  // Server starts successfully and listens on specified port
  it("should start the server and listen on the specified port", () => {
    const express = require("express");
    const app = express();
    const PORT = process.env.PORT || 3010;

    const listenMock = jest.spyOn(app, "listen");

    require("dotenv").config();
    require("mongoose");
    require("node-cron");

    // code_under_test

    expect(listenMock).toHaveBeenCalledWith(PORT, expect.any(Function));
  });

  // Cron job runs successfully and fetches and stores cryptocurrencies
  it("should run the cron job and fetch and store cryptocurrencies", () => {
    const cron = require("node-cron");
    const axios = require("axios");

    const cronScheduleMock = jest.spyOn(cron, "schedule");
    const axiosGetMock = jest.spyOn(axios, "get");

    require("express");
    require("mongoose");
    require("dotenv").config();

    // code_under_test

    expect(cronScheduleMock).toHaveBeenCalledWith(
      "0 * * * *",
      expect.any(Function)
    );
    expect(axiosGetMock).toHaveBeenCalledWith(
      "https://api.coingecko.com/api/v3/coins/list"
    );
  });

  // Price conversion request with valid parameters returns converted price
  it("should return the converted price when given valid parameters", async () => {
    const express = require("express");
    const app = express();
    const axios = require("axios");

    const axiosGetMock = jest.spyOn(axios, "get");
    const assetDetailsFindOneMock = jest
      .fn()
      .mockResolvedValue({ id: "fromCryptoId" });

    require("mongoose");
    require("node-cron");
    require("dotenv").config();

    // code_under_test

    const req = {
      body: {
        fromCurrency: "fromCurrency",
        toCurrency: "toCurrency",
        date: "2022-01-01",
      },
    };
    const res = {
      json: jest.fn(),
      status: jest.fn().mockReturnThis(),
    };

    await app.post("/convertPrice", async (req, res) => {
      // code_under_test
    })(req, res);

    expect(assetDetailsFindOneMock).toHaveBeenCalledWith({
      name: "fromCurrency",
    });
    expect(assetDetailsFindOneMock).toHaveBeenCalledWith({
      name: "toCurrency",
    });
    expect(axiosGetMock).toHaveBeenCalledWith(
      `https://api.coingecko.com/api/v3/coins/fromCryptoId/market_chart`,
      {
        params: {
          vs_currency: "toCryptoId",
          from: 1640995200,
          to: 1640995200,
        },
      }
    );
    expect(res.json).toHaveBeenCalledWith({ price: expect.any(Number) });
  });

  // Error connecting to MongoDB throws error and exits process
  it("should throw an error and exit the process when there is an error connecting to MongoDB", () => {
    const express = require("express");
    const app = express();
    const clientConnectMock = jest
      .fn()
      .mockRejectedValue(new Error("Connection error"));
    const consoleErrorMock = jest.spyOn(console, "error");
    const processExitMock = jest.spyOn(process, "exit");

    require("mongoose");
    require("node-cron");
    require("dotenv").config();

    // code_under_test

    expect(clientConnectMock).toHaveBeenCalled();
    expect(consoleErrorMock).toHaveBeenCalledWith(
      "Error connecting to MongoDB:",
      "Connection error"
    );
    expect(processExitMock).toHaveBeenCalledWith(1);
  });

  // Price conversion request with invalid fromCurrency returns 404 error
  it("should return 404 error when fromCurrency is invalid", async () => {
    const express = require("express");
    const app = express();
    const axios = require("axios");
    const AssetDetails = require("path/to/AssetDetails");

    const findOneMock = jest.spyOn(AssetDetails, "findOne");
    findOneMock.mockResolvedValue(null);

    const req = {
      body: {
        fromCurrency: "invalidCurrency",
        toCurrency: "validCurrency",
        date: "2022-01-01",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    // code_under_test

    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      error: "Cryptocurrency not found",
    });
  });

  // Price conversion request with invalid toCurrency returns 404 error
  it("should return 404 error when toCurrency is invalid", async () => {
    const express = require("express");
    const app = express();
    const axios = require("axios");
    const AssetDetails = require("path/to/AssetDetails");

    const findOneMock = jest.spyOn(AssetDetails, "findOne");
    findOneMock.mockResolvedValue(null);

    const req = {
      body: {
        fromCurrency: "validCurrency",
        toCurrency: "invalidCurrency",
        date: "2022-01-01",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    // code_under_test

    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({
      error: "Cryptocurrency not found",
    });
  });

  // Price conversion request with invalid date returns 404 error
  it("should return 404 error when date is invalid", async () => {
    const express = require("express");
    const app = express();
    const axios = require("axios");
    const AssetDetails = require("path/to/AssetDetails");

    const findOneMock = jest.spyOn(AssetDetails, "findOne");
    findOneMock.mockResolvedValue({ id: "validId" });

    const getMock = jest.spyOn(axios, "get");
    getMock.mockRejectedValue(new Error("Request failed"));

    const req = {
      body: {
        fromCurrency: "validCurrency",
        toCurrency: "validCurrency",
        date: "invalidDate",
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      json: jest.fn(),
    };

    // code_under_test

    expect(res.status).toHaveBeenCalledWith(404);
    expect(res.json).toHaveBeenCalledWith({ error: "Price data not found" });
  });
});
